#! /usr/bin/ruby -w



# Point

Point = Struct.new(:row, :col)



# Elements

TERRAINS = [:mountain,
            :forest,
            :desert,
            :swamp,
            :water,
           ]

ANIMALS = [:bears, :cougars]

BLUE_STRUCTURES  = [:blue_shack,  :blue_stone]
GREEN_STRUCTURES = [:green_shack, :green_stone]
WHITE_STRUCTURES = [:white_shack, :white_stone]
BLACK_STRUCTURES = [:black_shack, :black_stone]
STRUCTURES = BLUE_STRUCTURES  +
             GREEN_STRUCTURES +
             WHITE_STRUCTURES +
             BLACK_STRUCTURES

ELEMENTS = TERRAINS + ANIMALS + STRUCTURES



# Hexagon

class Hexagon
  attr_reader :distances

  def initialize()
    @distances = Hash[ELEMENTS.map{ |e| [e,nil] }]
  end
end



# Board

class Board
  @@width  = 12
  @@height = 8

  def initialize()
    @data = Array.new(@@width * @@height, Hexagon.new())
  end

  def self.is_in?(pos)
    return pos.col >= 0 && pos.col < @@width &&
           pos.row >= 0 && pos.row < @@height
  end

  def self.neighbours(pos)
    r, c = pos.row, pos.col
    return [
      Point.new(r-1,c  ),
      Point.new(r+1,c  ),
      Point.new(r,  c-1),
      Point.new(r,  c+1),
      Point.new(r-1,c+1),
      Point.new(r+1,c-1),
    ].select { |p| self.is_in?(p) }
  end

  def [](pos)
    return @data[pos.row * @@width + pos.col]
  end

  def set(pos, elements)
    def set_(b, p, e, d)
      if Board.is_in?(p)
        hex = b[p]
        if hex.distances[e] == nil || hex.distances[e] > d
          hex.distances[e] = d
          for n in Board.neighbours(p)
            set_(b, n, e, d+1)
          end
        end
      end
    end
    for e in elements
      set_(self, pos, e, 0)
    end
  end

  def distance(pos, element)
    hex = self[pos]
    if hex != nil
      # TODO handle nil, recurse on neighbours?
      return hex.distances[element]
    else
      return -1
    end
  end
end



# Clues

Clue = Struct.new(:elements, :predicate)

def within(d)
  return lambda { |x| x <= d }
end

def not_within(d)
  return lambda { |x| x > d }
end

def check(board, pos, clue)
  return clue.predicate.call(clue.elements.map{|e| board.distance(pos, e) }.min)
end

TERRAIN_PAIRS      = TERRAINS.product(TERRAINS).select{ |a,b| a < b }
TERRAIN_CLUES      = TERRAIN_PAIRS.map{ |a,b| Clue.new([a,b], within(0)) }
TERRAIN_NOT_CLUES  = TERRAIN_PAIRS.map{ |a,b| Clue.new([a,b], not_within(0)) }

WITHIN_1_ELEMENTS  = TERRAINS.map{ |t| [t] } + [ANIMALS]
WITHIN_1_CLUES     = WITHIN_1_ELEMENTS.map{ |es| Clue.new(es, within(1)) }
WITHIN_1_NOT_CLUES = WITHIN_1_ELEMENTS.map{ |es| Clue.new(es, not_within(1)) }

WITHIN_2_ELEMENTS  = ANIMALS
WITHIN_2_CLUES     = WITHIN_2_ELEMENTS.map{ |es| Clue.new(es, within(2)) }
WITHIN_2_NOT_CLUES = WITHIN_2_ELEMENTS.map{ |es| Clue.new(es, not_within(2)) }



# Test

b = Board.new()
b.set(Point.new(4,4), [:water, :bears])

puts b
