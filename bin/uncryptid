#! /usr/bin/ruby -w



### Point

Point = Struct.new(:row, :col)



### Elements

TERRAINS = [:desert,
            :forest,
            :mountain,
            :swamp,
            :water,
           ]

ANIMALS = [:bears, :cougars]

BLUE_STRUCTURES  = [:blue_shack,  :blue_stone]
GREEN_STRUCTURES = [:green_shack, :green_stone]
WHITE_STRUCTURES = [:white_shack, :white_stone]
BLACK_STRUCTURES = [:black_shack, :black_stone]



### Modes

Mode = Struct.new(:name, :shacks, :stones, :include_black?, :include_not?)

NORMAL   = Mode.new(:normal,
                    [:blue_shack, :green_shack, :white_shack],
                    [:blue_stone, :green_stone, :white_stone],
                    false, false)
ADVANCED = Mode.new(:advanced,
                    [:blue_shack, :green_shack, :white_shack, :black_shack],
                    [:blue_stone, :green_stone, :white_stone, :black_stone],
                    true, true)



### Cell

class Cell
  attr_reader :distances

  def initialize()
    @distances = Hash.new
  end
end



### Board

class Board
  @@width  = 12
  @@height = 8

  def initialize()
    @data = Array.new(@@width * @@height) { Cell.new }
  end

  def self.is_in?(pos)
    return pos.col >= 0 && pos.col < @@width &&
           pos.row >= 0 && pos.row < @@height
  end

  def self.neighbours(pos)
    r, c = pos.row, pos.col
    return [
      Point.new(r-1,c  ),
      Point.new(r+1,c  ),
      Point.new(r,  c-1),
      Point.new(r,  c+1),
      Point.new(r-1,c+1),
      Point.new(r+1,c-1),
    ].select { |p| self.is_in?(p) }
  end

  def [](pos)
    return @data[pos.row * @@width + pos.col] if Board.is_in?(pos)
  end

  def set(pos, elements)
    for e in elements
      queue = [[pos,0]]
      while (current, d = queue.shift)
        if (distances = self[current]&.distances) &&
           (distances[e] == nil || distances[e] > d)
          distances[e] = d
          queue += Board.neighbours(current).map{|p| [p,d+1]}
        end
      end
    end
  end

  def distance(pos, element)
    return self[pos]&.distances[element]
  end
end



### Clues

Clue = Struct.new(:text, :elements, :predicate)

def within(d)
  return lambda { |x| x <= d }
end

def not_within(d)
  return lambda { |x| x > d }
end

def check(board, pos, clue)
  return clue.predicate.call(clue.elements.map{|e| board.distance(pos, e) }.min)
end

def all_clues(mode)
  clues = []
  terrain_pairs = TERRAINS.product(TERRAINS).select{ |a,b| a < b }

  clues += terrain_pairs.map { |a,b| Clue.new("either #{a} or #{b}", [a,b], within(0)) }
  clues += TERRAINS.map { |t| Clue.new("within 1 of #{t}", [t], within(1)) }
  clues << Clue.new("within 1 of animal territory", ANIMALS, within(1))
  clues << Clue.new("within 2 of a standing stone", mode.stones, within(2))
  clues << Clue.new("within 2 of an abandoned shack", mode.shacks, within(2))
  clues << Clue.new("within 2 of bear territory", [:bears], within(2))
  clues << Clue.new("within 2 of cougar territory", [:cougars], within(2))
  clues << Clue.new("within 3 of blue structure", BLUE_STRUCTURES, within(3))
  clues << Clue.new("within 3 of green structure", GREEN_STRUCTURES, within(3))
  clues << Clue.new("within 3 of white structure", WHITE_STRUCTURES, within(3))
  if mode.include_black?
    clues << Clue.new("within 3 of black structure", BLACK_STRUCTURES, within(3))
  end

  if mode.include_not?
    clues += terrain_pairs.map { |a,b| Clue.new("neither #{a} nor #{b}", [a,b], not_within(0)) }
    clues += TERRAINS.map { |t| Clue.new("not within 1 of #{t}", [t], not_within(1)) }
    clues << Clue.new("not within 1 of animal territory", ANIMALS, not_within(1))
    clues << Clue.new("not within 2 of a standing stone", mode.stones, not_within(2))
    clues << Clue.new("not within 2 of an abandoned shack", mode.shacks, not_within(2))
    clues << Clue.new("not within 2 of bear territory", [:bears], not_within(2))
    clues << Clue.new("not within 2 of cougar territory", [:cougars], not_within(2))
    clues << Clue.new("not within 3 of blue structure", BLUE_STRUCTURES, not_within(3))
    clues << Clue.new("not within 3 of green structure", GREEN_STRUCTURES, not_within(3))
    clues << Clue.new("not within 3 of white structure", WHITE_STRUCTURES, not_within(3))
    if mode.include_black?
      clues << Clue.new("not within 3 of black structure", BLACK_STRUCTURES, not_within(3))
    end
  end

  return clues
end



### TMP

b = Board.new()
b.set(Point.new(4,4), [:water, :bears])
all_clues(NORMAL).each{ |c| puts c.text }
