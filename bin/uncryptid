#! /usr/bin/ruby -w
# coding: utf-8

require 'rvg/rvg'
include Magick



### Point

Point = Struct.new(:row, :col)



### Elements

TERRAINS = [:desert,
            :forest,
            :mountain,
            :swamp,
            :water,
           ]

ANIMALS = [:bears, :cougars]

BLUE_STRUCTURES  = [:blue_shack,  :blue_stone]
GREEN_STRUCTURES = [:green_shack, :green_stone]
WHITE_STRUCTURES = [:white_shack, :white_stone]
BLACK_STRUCTURES = [:black_shack, :black_stone]



### Modes

Mode = Struct.new(:name, :shacks, :stones, :include_black?, :include_not?)

NORMAL   = Mode.new(:normal,
                    [:blue_shack, :green_shack, :white_shack],
                    [:blue_stone, :green_stone, :white_stone],
                    false, false)
ADVANCED = Mode.new(:advanced,
                    [:blue_shack, :green_shack, :white_shack, :black_shack],
                    [:blue_stone, :green_stone, :white_stone, :black_stone],
                    true, true)



### Cell

class Cell
  attr_reader :distances
  attr_accessor :type

  def initialize()
    @distances = Hash.new
    @distances.default = 4
  end
end



### Board

class Board
  @@width  = 8
  @@height = 8

  def initialize()
    @data = Array.new(@@width * @@height) { Cell.new }
  end

  def self.is_in?(pos)
    return pos.col >= 0 && pos.col < @@width &&
           pos.row >= 0 && pos.row < @@height
  end

  def self.neighbours(pos)
    r, c = pos.row, pos.col
    return [
      Point.new(r-1,c  ),
      Point.new(r+1,c  ),
      Point.new(r,  c-1),
      Point.new(r,  c+1),
      Point.new(r-1,c+1),
      Point.new(r+1,c-1),
    ].select { |p| self.is_in?(p) }
  end

  def [](pos)
    return @data[pos.row * @@width + pos.col] if Board.is_in?(pos)
  end

  def set(pos, type, elements)
    self[pos].type = type
    for e in elements + [type]
      queue = [[pos,0]]
      while (current, d = queue.shift)
        ds = self[current].distances
        if d < ds[e]
          ds[e] = d
          queue += Board.neighbours(current).map{|p| [p,d+1]}
        end
      end
    end
  end

  def distance(pos, element)
    return self[pos]&.distances[element]
  end

  def draw(filename)
    rvg = RVG.new(1200,800).viewbox(0,0,1200,800) do |canvas|
      canvas.background_fill = 'white'
      colors = { :forest   => 'LightGreen',
                 :desert   => 'khaki',
                 :mountain => 'LightGrey',
                 :water    => 'PaleTurquoise1',
                 :swamp    => 'plum',
               }
      dy = Math.sqrt(3) / 2.0
      size = 32
      canvas.translate(80, 600)

      for y in 0 ... @@height
        for x in 0 ... @@width
          hex = self[Point.new(y,x)]
          if hex.type
            canvas.g.translate(size * (x+y) * 1.5, size * (x-y) * dy) do |body|
              body.styles(:fill         => colors[hex.type],
                          :stroke       => 'black',
                          :stroke_width => 2,
                         )
              body.polygon(-1.0 * size,  0,
                           -0.5 * size,  dy * size,
                           +0.5 * size,  dy * size,
                           +1.0 * size,  0,
                           +0.5 * size, -dy * size,
                           -0.5 * size, -dy * size)
            end
          end
        end
      end
    end
    rvg.draw.write(filename)
  end
end



### Clues

Clue = Struct.new(:text, :elements, :predicate)

def within(d)
  return lambda { |x| x <= d }
end

def not_within(d)
  return lambda { |x| x > d }
end

def check(board, pos, clue)
  return clue.predicate.call(clue.elements.map{ |e| board.distance(pos, e) }.min)
end

def all_clues(mode)
  clues = []
  terrain_pairs = TERRAINS.product(TERRAINS).select{ |a,b| a < b }

  clues += terrain_pairs.map { |a,b| Clue.new("either #{a} or #{b}", [a,b], within(0)) }
  clues += TERRAINS.map { |t| Clue.new("within 1 of #{t}", [t], within(1)) }
  clues << Clue.new("within 1 of animal territory", ANIMALS, within(1))
  clues << Clue.new("within 2 of a standing stone", mode.stones, within(2))
  clues << Clue.new("within 2 of an abandoned shack", mode.shacks, within(2))
  clues << Clue.new("within 2 of bear territory", [:bears], within(2))
  clues << Clue.new("within 2 of cougar territory", [:cougars], within(2))
  clues << Clue.new("within 3 of blue structure", BLUE_STRUCTURES, within(3))
  clues << Clue.new("within 3 of green structure", GREEN_STRUCTURES, within(3))
  clues << Clue.new("within 3 of white structure", WHITE_STRUCTURES, within(3))
  if mode.include_black?
    clues << Clue.new("within 3 of black structure", BLACK_STRUCTURES, within(3))
  end

  if mode.include_not?
    clues += terrain_pairs.map { |a,b| Clue.new("neither #{a} nor #{b}", [a,b], not_within(0)) }
    clues += TERRAINS.map { |t| Clue.new("not within 1 of #{t}", [t], not_within(1)) }
    clues << Clue.new("not within 1 of animal territory", ANIMALS, not_within(1))
    clues << Clue.new("not within 2 of a standing stone", mode.stones, not_within(2))
    clues << Clue.new("not within 2 of an abandoned shack", mode.shacks, not_within(2))
    clues << Clue.new("not within 2 of bear territory", [:bears], not_within(2))
    clues << Clue.new("not within 2 of cougar territory", [:cougars], not_within(2))
    clues << Clue.new("not within 3 of blue structure", BLUE_STRUCTURES, not_within(3))
    clues << Clue.new("not within 3 of green structure", GREEN_STRUCTURES, not_within(3))
    clues << Clue.new("not within 3 of white structure", WHITE_STRUCTURES, not_within(3))
    if mode.include_black?
      clues << Clue.new("not within 3 of black structure", BLACK_STRUCTURES, not_within(3))
    end
  end

  return clues
end



### TMP

b = Board.new()
b.set(Point.new(4,4), :water,    [:bears, :white_stone])
b.set(Point.new(6,2), :mountain, [])
b.set(Point.new(6,1), :swamp,    [])
b.set(Point.new(3,0), :desert,   [])
b.set(Point.new(3,1), :desert,   [])
b.set(Point.new(3,2), :desert,   [])
b.set(Point.new(3,3), :desert,   [])
b.set(Point.new(4,1), :forest,   [])
b.set(Point.new(4,2), :forest,   [])
b.set(Point.new(4,3), :water ,   [])
b.set(Point.new(5,4), :forest,   [])
all_clues(NORMAL).each{ |c| puts c.text }
b.draw("test.png")
